# Security Audit & Vulnerability Fixes

**Task ID**: TASK-030
**Created**: 2025-10-20
**Assigned To**: Security Engineer / Senior Developer
**Status**: `pending`
**Priority**: `critical`
**Estimated Time**: 12 hours
**Actual Time**: - (update when complete)

---

## 1. TASK OVERVIEW

### Objective
Conduct comprehensive security audit covering OWASP Top 10 vulnerabilities, implement input validation, SQL injection prevention, XSS/CSRF protection, rate limiting, dependency vulnerability scanning, and penetration testing to ensure zero critical vulnerabilities.

### User Story
**As a** security-conscious user
**I want** the application to be secure from common vulnerabilities
**So that** my data is protected and I can trust the system with sensitive information

### Business Value
Security is critical for market viability and regulatory compliance. A single security breach can destroy customer trust, result in legal liability, and cause business failure. Achieving zero critical vulnerabilities ensures data protection, maintains customer confidence, and meets SOC 2 / ISO 27001 requirements. Essential for enterprise adoption.

---

## 2. REQUIREMENTS & ACCEPTANCE CRITERIA

### Functional Requirements

**FR-1**: System SHALL prevent OWASP Top 10 vulnerabilities
- A01:2021 - Broken Access Control
- A02:2021 - Cryptographic Failures
- A03:2021 - Injection
- A04:2021 - Insecure Design
- A05:2021 - Security Misconfiguration
- A06:2021 - Vulnerable and Outdated Components
- A07:2021 - Identification and Authentication Failures
- A08:2021 - Software and Data Integrity Failures
- A09:2021 - Security Logging and Monitoring Failures
- A10:2021 - Server-Side Request Forgery (SSRF)

**FR-2**: System SHALL implement input validation
- Validate all user inputs on server-side
- Sanitize inputs to prevent injection
- Use allowlist validation (not blocklist)
- Validate data types, lengths, formats
- Reject invalid inputs with clear errors

**FR-3**: System SHALL prevent SQL injection
- Use parameterized queries exclusively
- Never concatenate user input into SQL
- Use Supabase RLS for additional protection
- Validate all database inputs

**FR-4**: System SHALL prevent XSS attacks
- Escape all user-generated content in HTML
- Use Content Security Policy (CSP) headers
- Sanitize inputs before rendering
- Use React's built-in XSS protection

**FR-5**: System SHALL prevent CSRF attacks
- Implement CSRF tokens for state-changing operations
- Validate origin/referer headers
- Use SameSite cookies
- Require authentication for all sensitive operations

**FR-6**: System SHALL implement rate limiting
- API endpoints rate limited (100 req/min per IP)
- Authentication endpoints stricter (5 req/min)
- Prevent brute force attacks
- Return 429 Too Many Requests

**FR-7**: System SHALL scan for dependency vulnerabilities
- Run npm audit regularly
- No critical or high vulnerabilities
- Dependencies up to date
- Remove unused dependencies

**FR-8**: System SHALL implement secure authentication
- JWT tokens with short expiration (1 hour)
- Secure session management
- Password complexity requirements (via Clerk)
- Multi-factor authentication support

**FR-9**: System SHALL protect sensitive data
- Environment variables never exposed to client
- API keys stored securely
- PII encrypted at rest and in transit
- Secure headers (HTTPS, HSTS, etc.)

**FR-10**: System SHALL implement security logging
- Log all authentication attempts
- Log all authorization failures
- Log suspicious activities
- Never log sensitive data (passwords, tokens)

### Acceptance Criteria

- [ ] **AC-1**: Zero critical vulnerabilities found
- [ ] **AC-2**: Zero high-severity vulnerabilities found
- [ ] **AC-3**: All OWASP Top 10 addressed
- [ ] **AC-4**: Input validation on all endpoints
- [ ] **AC-5**: SQL injection prevention verified
- [ ] **AC-6**: XSS protection verified
- [ ] **AC-7**: CSRF protection implemented
- [ ] **AC-8**: Rate limiting configured
- [ ] **AC-9**: npm audit shows no critical/high vulnerabilities
- [ ] **AC-10**: Penetration testing passed
- [ ] **AC-11**: Security headers configured
- [ ] **AC-12**: Security logging implemented
- [ ] **AC-13**: Code review by security expert approved

### Non-Functional Requirements

- **Security**: Zero critical/high vulnerabilities
- **Compliance**: OWASP Top 10 compliance
- **Performance**: Security measures don't degrade performance >10%
- **Auditability**: All security events logged

---

## 3. TEST-DRIVEN DEVELOPMENT (TDD) APPROACH

### Step 1: Write Security Tests FIRST (Red Phase)

**Test Files to Create**:
```
__tests__/security/owasp-top-10.test.ts
__tests__/security/input-validation.test.ts
__tests__/security/sql-injection.test.ts
__tests__/security/xss-protection.test.ts
__tests__/security/csrf-protection.test.ts
__tests__/security/rate-limiting.test.ts
__tests__/security/authentication.test.ts
__tests__/security/authorization.test.ts
scripts/security-audit.sh
scripts/penetration-test.sh
```

**Example Test - SQL Injection Prevention**:
```typescript
// __tests__/security/sql-injection.test.ts
import { describe, it, expect } from 'vitest'
import { createTestClient } from '../helpers/test-client'

describe('SQL Injection Prevention', () => {
  const testClient = createTestClient()

  it('should reject SQL injection in search query', async () => {
    const maliciousQuery = "'; DROP TABLE flight_requests; --"

    const response = await testClient
      .get(`/api/requests?search=${encodeURIComponent(maliciousQuery)}`)
      .set('Authorization', `Bearer ${testClient.authToken}`)

    expect(response.status).toBe(400)
    expect(response.body.error).toContain('Invalid input')
  })

  it('should prevent SQL injection in POST body', async () => {
    const maliciousData = {
      departure_airport: "KTEB'; DROP TABLE users; --",
      arrival_airport: 'KVNY',
      passengers: 6,
      departure_date: '2025-11-15'
    }

    const response = await testClient
      .post('/api/requests')
      .set('Authorization', `Bearer ${testClient.authToken}`)
      .send(maliciousData)

    expect(response.status).toBe(400)
    expect(response.body.error).toContain('Invalid airport code')
  })

  it('should use parameterized queries', async () => {
    // Verify implementation uses parameterized queries
    const routeFile = readFileSync('app/api/requests/route.ts', 'utf-8')

    // Should NOT contain raw string concatenation
    expect(routeFile).not.toMatch(/\$\{.*\}.*FROM/)
    expect(routeFile).not.toMatch(/\+.*\+.*FROM/)

    // Should use Supabase client methods (which are parameterized)
    expect(routeFile).toMatch(/supabase\.from\(/)
  })
})
```

**Example Test - XSS Protection**:
```typescript
// __tests__/security/xss-protection.test.ts
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import { RequestList } from '@/components/RequestList'

describe('XSS Protection', () => {
  it('should escape HTML in user input', () => {
    const maliciousRequest = {
      id: '1',
      departure_airport: 'KTEB',
      arrival_airport: '<script>alert("XSS")</script>',
      passengers: 6,
      status: 'CREATED'
    }

    render(<RequestList requests={[maliciousRequest]} />)

    // Should render escaped text, not execute script
    expect(screen.getByText(/&lt;script&gt;/)).toBeInTheDocument()
    expect(document.querySelectorAll('script').length).toBe(0)
  })

  it('should sanitize markdown content', () => {
    const maliciousMarkdown = `
      # Heading
      <img src=x onerror="alert('XSS')">
      [Link](javascript:alert('XSS'))
    `

    const sanitized = sanitizeMarkdown(maliciousMarkdown)

    expect(sanitized).not.toContain('javascript:')
    expect(sanitized).not.toContain('onerror')
  })

  it('should have CSP headers', async () => {
    const response = await fetch('http://localhost:3000')
    const csp = response.headers.get('Content-Security-Policy')

    expect(csp).toBeDefined()
    expect(csp).toContain("default-src 'self'")
    expect(csp).not.toContain("'unsafe-inline'")
    expect(csp).not.toContain("'unsafe-eval'")
  })
})
```

**Example Test - CSRF Protection**:
```typescript
// __tests__/security/csrf-protection.test.ts
import { describe, it, expect } from 'vitest'
import { createTestClient } from '../helpers/test-client'

describe('CSRF Protection', () => {
  const testClient = createTestClient()

  it('should reject requests without valid origin', async () => {
    const response = await testClient
      .post('/api/requests')
      .set('Authorization', `Bearer ${testClient.authToken}`)
      .set('Origin', 'https://malicious-site.com')
      .send({
        departure_airport: 'KTEB',
        arrival_airport: 'KVNY',
        passengers: 6,
        departure_date: '2025-11-15'
      })

    expect(response.status).toBe(403)
  })

  it('should validate referer header', async () => {
    const response = await testClient
      .post('/api/requests')
      .set('Authorization', `Bearer ${testClient.authToken}`)
      .set('Referer', 'https://malicious-site.com')
      .send({
        departure_airport: 'KTEB',
        arrival_airport: 'KVNY',
        passengers: 6,
        departure_date: '2025-11-15'
      })

    expect(response.status).toBe(403)
  })

  it('should use SameSite cookies', async () => {
    const response = await fetch('http://localhost:3000/api/auth/session')
    const setCookie = response.headers.get('Set-Cookie')

    expect(setCookie).toContain('SameSite=Strict')
  })
})
```

**Example Test - Rate Limiting**:
```typescript
// __tests__/security/rate-limiting.test.ts
import { describe, it, expect } from 'vitest'
import { createTestClient } from '../helpers/test-client'

describe('Rate Limiting', () => {
  const testClient = createTestClient()

  it('should rate limit API requests', async () => {
    const requests = []

    // Make 150 requests (limit is 100/min)
    for (let i = 0; i < 150; i++) {
      const promise = testClient
        .get('/api/requests')
        .set('Authorization', `Bearer ${testClient.authToken}`)

      requests.push(promise)
    }

    const responses = await Promise.all(requests)
    const rateLimited = responses.filter(r => r.status === 429)

    expect(rateLimited.length).toBeGreaterThan(0)
  })

  it('should rate limit authentication attempts', async () => {
    const requests = []

    // Make 10 login attempts (limit is 5/min)
    for (let i = 0; i < 10; i++) {
      const promise = testClient
        .post('/api/auth/signin')
        .send({
          email: 'test@example.com',
          password: 'wrong-password'
        })

      requests.push(promise)
    }

    const responses = await Promise.all(requests)
    const rateLimited = responses.filter(r => r.status === 429)

    expect(rateLimited.length).toBeGreaterThan(0)
  })

  it('should return Retry-After header', async () => {
    // Exceed rate limit
    for (let i = 0; i < 101; i++) {
      await testClient
        .get('/api/requests')
        .set('Authorization', `Bearer ${testClient.authToken}`)
    }

    const response = await testClient
      .get('/api/requests')
      .set('Authorization', `Bearer ${testClient.authToken}`)

    expect(response.status).toBe(429)
    expect(response.headers['retry-after']).toBeDefined()
  })
})
```

**Example Test - Input Validation**:
```typescript
// __tests__/security/input-validation.test.ts
import { describe, it, expect } from 'vitest'
import { validateFlightRequest } from '@/lib/validation'

describe('Input Validation', () => {
  it('should reject invalid airport codes', () => {
    const result = validateFlightRequest({
      departure_airport: 'INVALID123',
      arrival_airport: 'KVNY',
      passengers: 6,
      departure_date: '2025-11-15'
    })

    expect(result.valid).toBe(false)
    expect(result.errors).toContain('Invalid departure airport')
  })

  it('should reject negative passenger count', () => {
    const result = validateFlightRequest({
      departure_airport: 'KTEB',
      arrival_airport: 'KVNY',
      passengers: -1,
      departure_date: '2025-11-15'
    })

    expect(result.valid).toBe(false)
    expect(result.errors).toContain('Invalid passenger count')
  })

  it('should reject excessively long strings', () => {
    const result = validateFlightRequest({
      departure_airport: 'KTEB',
      arrival_airport: 'KVNY',
      passengers: 6,
      departure_date: '2025-11-15',
      notes: 'A'.repeat(10001) // Max is 10000
    })

    expect(result.valid).toBe(false)
    expect(result.errors).toContain('Notes too long')
  })

  it('should reject special characters in names', () => {
    const result = validateFlightRequest({
      departure_airport: 'KTEB',
      arrival_airport: 'KVNY',
      passengers: 6,
      departure_date: '2025-11-15',
      client_name: 'John<script>alert("XSS")</script>'
    })

    expect(result.valid).toBe(false)
    expect(result.errors).toContain('Invalid characters in name')
  })

  it('should use allowlist validation for enums', () => {
    const result = validateFlightRequest({
      departure_airport: 'KTEB',
      arrival_airport: 'KVNY',
      passengers: 6,
      departure_date: '2025-11-15',
      aircraft_category: 'INVALID_CATEGORY'
    })

    expect(result.valid).toBe(false)
    expect(result.errors).toContain('Invalid aircraft category')
  })
})
```

**Security Audit Script**:
```bash
#!/bin/bash
# scripts/security-audit.sh

echo "üîí Running Security Audit..."

# 1. Dependency vulnerability scan
echo "üì¶ Scanning dependencies..."
npm audit --audit-level=high
if [ $? -ne 0 ]; then
  echo "‚ùå Found high/critical vulnerabilities"
  exit 1
fi

# 2. Check for exposed secrets
echo "üîë Checking for exposed secrets..."
git secrets --scan || true

# 3. OWASP dependency check
echo "üõ°Ô∏è Running OWASP dependency check..."
dependency-check --scan . --out ./security-reports

# 4. Code security scan
echo "üîç Running code security scan..."
npm run lint:security

# 5. Check security headers
echo "üìã Checking security headers..."
curl -I http://localhost:3000 | grep -E "(Strict-Transport-Security|Content-Security-Policy|X-Frame-Options|X-Content-Type-Options)"

# 6. Check for hardcoded secrets
echo "üîê Checking for hardcoded secrets..."
grep -r "password\s*=\s*['\"]" --include="*.ts" --include="*.tsx" --exclude-dir=node_modules
if [ $? -eq 0 ]; then
  echo "‚ùå Found potential hardcoded secrets"
  exit 1
fi

echo "‚úÖ Security audit complete"
```

**Run Tests** (should FAIL initially):
```bash
npm run test:security
# Expected: Security tests fail, vulnerabilities found
```

### Step 2: Implement Security Fixes (Green Phase)

**Input Validation**:
```typescript
// lib/validation/flight-request.ts
import { z } from 'zod'

const airportCodeRegex = /^[A-Z]{4}$/
const nameRegex = /^[a-zA-Z\s'-]+$/

export const flightRequestSchema = z.object({
  departure_airport: z.string()
    .regex(airportCodeRegex, 'Invalid airport code')
    .length(4, 'Airport code must be 4 characters'),

  arrival_airport: z.string()
    .regex(airportCodeRegex, 'Invalid airport code')
    .length(4, 'Airport code must be 4 characters'),

  passengers: z.number()
    .int('Passenger count must be integer')
    .min(1, 'At least 1 passenger required')
    .max(50, 'Maximum 50 passengers'),

  departure_date: z.string()
    .datetime('Invalid date format')
    .refine((date) => new Date(date) > new Date(), {
      message: 'Date must be in the future'
    }),

  client_name: z.string()
    .regex(nameRegex, 'Invalid characters in name')
    .max(100, 'Name too long')
    .optional(),

  notes: z.string()
    .max(10000, 'Notes too long')
    .optional(),

  aircraft_category: z.enum([
    'light',
    'midsize',
    'heavy',
    'ultra-long-range'
  ]).optional()
})

export function validateFlightRequest(data: unknown) {
  const result = flightRequestSchema.safeParse(data)

  return {
    valid: result.success,
    data: result.success ? result.data : null,
    errors: result.success ? [] : result.error.errors.map(e => e.message)
  }
}
```

**Rate Limiting**:
```typescript
// lib/middleware/rate-limit.ts
import { Ratelimit } from '@upstash/ratelimit'
import { Redis } from '@upstash/redis'

const redis = new Redis({
  url: process.env.REDIS_URL!,
  token: process.env.REDIS_TOKEN!
})

// API endpoints: 100 req/min
export const apiLimiter = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(100, '1 m'),
  analytics: true
})

// Auth endpoints: 5 req/min
export const authLimiter = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(5, '1 m'),
  analytics: true
})

export async function rateLimit(
  identifier: string,
  limiter: Ratelimit
): Promise<{ success: boolean; remaining: number }> {
  const { success, remaining } = await limiter.limit(identifier)

  return { success, remaining }
}
```

**Security Headers**:
```typescript
// middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  const response = NextResponse.next()

  // Security headers
  response.headers.set('X-Frame-Options', 'DENY')
  response.headers.set('X-Content-Type-Options', 'nosniff')
  response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin')
  response.headers.set('Permissions-Policy', 'geolocation=(), microphone=(), camera=()')

  // HSTS
  response.headers.set(
    'Strict-Transport-Security',
    'max-age=31536000; includeSubDomains; preload'
  )

  // CSP
  response.headers.set(
    'Content-Security-Policy',
    [
      "default-src 'self'",
      "script-src 'self' 'unsafe-inline' 'unsafe-eval'",
      "style-src 'self' 'unsafe-inline'",
      "img-src 'self' data: https:",
      "font-src 'self'",
      "connect-src 'self' https://api.openai.com",
      "frame-ancestors 'none'"
    ].join('; ')
  )

  return response
}
```

**CSRF Protection**:
```typescript
// lib/middleware/csrf.ts
import { NextRequest, NextResponse } from 'next/server'

const ALLOWED_ORIGINS = [
  'http://localhost:3000',
  'https://jetvision-assistant.vercel.app'
]

export function validateOrigin(request: NextRequest): boolean {
  const origin = request.headers.get('origin')
  const referer = request.headers.get('referer')

  if (!origin && !referer) {
    return false
  }

  const requestOrigin = origin || new URL(referer!).origin

  return ALLOWED_ORIGINS.includes(requestOrigin)
}

export function csrfProtection(request: NextRequest) {
  if (request.method !== 'GET' && request.method !== 'HEAD') {
    if (!validateOrigin(request)) {
      return NextResponse.json(
        { error: 'Invalid origin' },
        { status: 403 }
      )
    }
  }

  return null
}
```

**Run Tests Again**:
```bash
npm run test:security
# Expected: Security tests now pass ‚úì
```

### Step 3: Verify and Harden (Blue Phase)

- Run penetration testing
- Review security logs
- Update dependencies
- Document security measures

---

## 4. IMPLEMENTATION STEPS

### Pre-Implementation Checklist

- [ ] Security scanning tools installed
- [ ] Test environment configured
- [ ] Security baselines documented

### Step-by-Step Implementation

**Step 1**: Scan Current State
```bash
npm audit
npm run lint:security
./scripts/security-audit.sh
```

**Step 2**: Fix Dependency Vulnerabilities
```bash
npm audit fix
npm update
```

**Step 3**: Implement Input Validation (Zod schemas)
- Create validation schemas
- Apply to all API routes
- Test edge cases

**Step 4**: Implement Rate Limiting (Upstash Redis)
- Configure rate limiters
- Apply to API routes
- Test limits

**Step 5**: Configure Security Headers
- Update middleware
- Test headers
- Verify CSP

**Step 6**: Implement CSRF Protection
- Validate origins
- Check referers
- Configure SameSite cookies

**Step 7**: Security Logging
- Log auth attempts
- Log authorization failures
- Set up alerts

**Step 8**: Penetration Testing
```bash
./scripts/penetration-test.sh
```

**Step 9**: Document Security Measures
- Security policies
- Incident response plan
- Compliance checklist

### Implementation Validation

- [ ] Zero critical vulnerabilities
- [ ] All security tests pass
- [ ] Penetration testing passed
- [ ] Security documentation complete

---

## 5. GIT WORKFLOW

### Branch Creation
```bash
git checkout main
git pull origin main
git checkout -b security/audit-and-fixes
```

### Commit Guidelines
```bash
git add lib/validation/
git commit -m "security: add Zod input validation for all API routes"

git add lib/middleware/rate-limit.ts
git commit -m "security: implement rate limiting with Upstash Redis"

git add middleware.ts
git commit -m "security: add security headers (CSP, HSTS, X-Frame-Options)"

git add __tests__/security/
git commit -m "test(security): add comprehensive security test suite"

git push origin security/audit-and-fixes
```

### Pull Request
```bash
gh pr create --title "Security: Comprehensive Audit & Vulnerability Fixes" \
  --body "Implements security hardening and fixes all vulnerabilities.

**Security Improvements:**
- ‚úÖ Zero critical/high vulnerabilities
- ‚úÖ OWASP Top 10 compliance
- ‚úÖ Input validation on all endpoints
- ‚úÖ Rate limiting (100 req/min API, 5 req/min auth)
- ‚úÖ Security headers (CSP, HSTS, X-Frame-Options)
- ‚úÖ CSRF protection
- ‚úÖ SQL injection prevention
- ‚úÖ XSS protection
- ‚úÖ Security logging

**Tests:**
- 50+ security tests
- Penetration testing passed
- Dependency audit clean

Closes #TASK-030"
```

---

## 6-11. STANDARD SECTIONS

(Following template structure)

---

**Task Status**: ‚è≥ PENDING

**Completed By**: -
**Completed Date**: -
